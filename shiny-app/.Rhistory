As can be seen from the plot above, for selection of $\hat{\lambda}$ around 5,
the average of the sample mean falls within the confidence interval at least 95% of the time.
Note that the true rate, $\lambda$ is 5.
## ------------------------------------------------------------------------
set.seed(3)
## variables that control the simulation
lambda <- 0.2
num_sim <- 1000
sample_size <- 40
## Create a matrix of 1000 rows with the columns corresponding to random simulation 40 times
sim <- matrix(rexp(num_sim*sample_size, rate=lambda), num_sim, sample_size)
row_means <- rowMeans(sim)
## ------------------------------------------------------------------------
# plot the histogram of averages
hist(row_means, breaks=50, prob=TRUE,
main="Distribution of averages of samples,
drawn from exponential distribution with lambda=0.2",
xlab="")
# density of the averages of samples
lines(density(row_means))
# theoretical center of distribution
abline(v=1/lambda, col="red")
# theoretical density of the averages of samples
xfit <- seq(min(row_means), max(row_means), length=100)
yfit <- dnorm(xfit, mean=1/lambda, sd=(1/lambda/sqrt(sample_size)))
lines(xfit, yfit, pch=22, col="red", lty=2)
# add legend
legend('topright', c("simulation", "theoretical"), lty=c(1,2), col=c("black", "red"))
## ------------------------------------------------------------------------
qqnorm(row_means); qqline(row_means)
## ------------------------------------------------------------------------
lambda_vals <- seq(4, 6, by=0.01)
coverage <- sapply(lambda_vals, function(lamb) {
mu_hats <- rowMeans(matrix(rexp(sample_size*num_sim, rate=0.2),
num_sim, sample_size))
ll <- mu_hats - qnorm(0.975) * sqrt(1/lambda**2/sample_size)
ul <- mu_hats + qnorm(0.975) * sqrt(1/lambda**2/sample_size)
mean(ll < lamb & ul > lamb)
})
library(ggplot2)
qplot(lambda_vals, coverage) + geom_hline(yintercept=0.95)
echo $path
```{r}
# load neccesary libraries
library(ggplot2)
# set constants
λ <- 0.2# lambda for rexp
n <- 40 # number of exponetials
numberOfSimulations <- 1000 # number of tests
# set the seed to create reproducability
set.seed(11081979)
# run the test resulting in n x numberOfSimulations matrix
exponentialDistributions <- matrix(data=rexp(n * numberOfSimulations, λ), nrow=numberOfSimulations)
exponentialDistributionMeans <- data.frame(means=apply(exponentialDistributions, 1, mean))
#summary(cars)
```
The theoretical quantiles also match closely with the actual quantiles. These three evidences prove that the distribution is approximately normal.
Boxplot comparison between Vitamin C dose levels and tooth length:
title(xlab=paste("Repeated Sampling, Covered the Popu Mean",round(nCovered/nExperiments*100),"% of times"))
mu = 10
sigma = 5
alpha = 0.05
n=20
nExperiments = 100
results.U = rep(0,nExperiments)
results.L = rep(0,nExperiments)
titleOfPlot = paste("CI for Popu Mean, Normal Case and Variance Known (Sample size Per Sampling =",n,")")
plot(c(0,nExperiments),c(mu - 1.5*qnorm(1 -alpha/2) * sigma/sqrt(n),mu + 1.5*qnorm(1 -alpha/2) * sigma/sqrt(n)),main=titleOfPlot,xlab="",type="n",ylab=paste(round((1-alpha)*100),"Coverage"))
abline(h = mu,lwd=2)
nCovered = 0
for (i in 1:nExperiments) {
sampledData = rnorm(n,mu,sigma)
results.U[i] = mean(sampledData) + qnorm(1 - alpha/2)*sigma/sqrt(n)
results.L[i] = mean(sampledData) - qnorm(1 - alpha/2)*sigma/sqrt(n)
points(i,mean(sampledData),cex=0.5,pch=16)
if (mu < results.U[i] & mu > results.L[i]) {
lines(c(i,i),c(results.U[i],results.L[i]),col="blue")
nCovered = nCovered + 1
} else {
lines(c(i,i),c(results.U[i],results.L[i]),col="red")
}
}
title(xlab=paste("Repeated Sampling, Covered the Popu Mean",round(nCovered/nExperiments*100),"% of times"))
df = c(5,30,100)
color = c("red","blue","purple")
x.seq = seq(-3,3,0.05)
plot(c(min(x.seq),max(x.seq)),c(0,0.5),type="n",main="T Distribution",ylab="P(x)",xlab="x")
for (i in 1:length(df)) {
y = dt(x.seq,df[i])
lines(x.seq,y,col=color[i],lwd=2)
}
lines(x.seq,dnorm(x.seq),col="black",lwd=2,lty=2)
legend("topright",legend=c(paste("Degrees of Freedom:",df),"Standard Normal Distribution"),col=c(color,"black"),lwd=2,lty=c(1,1,1,2))
find.pacjage("devtools")
find.package("devtools")
install.packages("devtools")
library(devtools)
install.packages("KernSmooth")
library(KernSmooth)
setwd("C:/DCI/Data/metadata")
library(plyr)
setwd("C:/DCI/Data/metadata")
setwd("C:/DCI/Data/metadata")
getwd()
setwd("C:/DCI/Data/metadata")
setwd("C:MyData/DCI/reports")
install.packages("reshape2")
library(reshape2)
install.packages("Rcpp")
Sys.getenv()['PATH']
find_rtools(T)
library(devtools)
install.packages("devtools")
library(devtools)
install.packages("reshape2")
library(reshape2)
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
#' Aggregate dataset by state
#'
#' @param dt data.table
#' @param year_min integer
#' @param year_max integer
#' @param evtypes character vector
#' @return data.table
#'
aggregate_by_state <- function(dt, year_min, year_max, evtypes) {
replace_na <- function(x) ifelse(is.na(x), 0, x)
round_2 <- function(x) round(x, 2)
states <- data.table(STATE=sort(unique(dt$STATE)))
aggregated <- dt %>% filter(YEAR >= year_min, YEAR <= year_max, EVTYPE %in% evtypes) %>%
group_by(STATE) %>%
summarise_each(funs(sum), COUNT:CROPDMG)
# We want all states to be present even if nothing happened
left_join(states,  aggregated, by = "STATE") %>%
mutate_each(funs(replace_na), FATALITIES:CROPDMG) %>%
mutate_each(funs(round_2), PROPDMG, CROPDMG)
}
#' Aggregate dataset by year
#'
#' @param dt data.table
#' @param year_min integer
#' @param year_max integer
#' @param evtypes character vector
#' @return data.table
#'
aggregate_by_year <- function(dt, year_min, year_max, evtypes) {
round_2 <- function(x) round(x, 2)
# Filter
dt %>% filter(YEAR >= year_min, YEAR <= year_max, EVTYPE %in% evtypes) %>%
# Group and aggregate
group_by(YEAR) %>% summarise_each(funs(sum), COUNT:CROPDMG) %>%
# Round
mutate_each(funs(round_2), PROPDMG, CROPDMG) %>%
rename(
Year = YEAR, Count = COUNT,
Fatalities = FATALITIES, Injuries = INJURIES,
Property = PROPDMG, Crops = CROPDMG
)
}
#' Add Affected column based on category
#'
#' @param dt data.table
#' @param category character
#' @return data.table
#'
compute_affected <- function(dt, category) {
dt %>% mutate(Affected = {
if(category == 'both') {
INJURIES + FATALITIES
} else if(category == 'fatalities') {
FATALITIES
} else {
INJURIES
}
})
}
#' Add Damages column based on category
#'
#' @param dt data.table
#' @param category character
#' @return data.table
#'
compute_damages <- function(dt, category) {
dt %>% mutate(Damages = {
if(category == 'both') {
PROPDMG + CROPDMG
} else if(category == 'crops') {
CROPDMG
} else {
PROPDMG
}
})
}
#' Prepare map of economic or population impact
#'
#' @param dt data.table
#' @param states_map data.frame returned from map_data("state")
#' @param year_min integer
#' @param year_max integer
#' @param fill character name of the variable
#' @param title character
#' @param low character hex
#' @param high character hex
#' @return ggplot
#'
plot_impact_by_state <- function (dt, states_map, year_min, year_max, fill, title, low = "#fff5eb", high = "#d94801") {
title <- sprintf(title, year_min, year_max)
p <- ggplot(dt, aes(map_id = STATE))
p <- p + geom_map(aes_string(fill = fill), map = states_map, colour='black')
p <- p + expand_limits(x = states_map$long, y = states_map$lat)
p <- p + coord_map() + theme_bw()
p <- p + labs(x = "Long", y = "Lat", title = title)
p + scale_fill_gradient(low = low, high = high)
}
#' Prepare plots of impact by year
#'
#' @param dt data.table
#' @param dom
#' @param yAxisLabel
#' @param desc
#' @return plot
#'
plot_impact_by_year <- function(dt, dom, yAxisLabel, desc = FALSE) {
impactPlot <- nPlot(
value ~ Year, group = "variable",
data = melt(dt, id="Year") %>% arrange(Year, if (desc) { desc(variable) } else { variable }),
type = "stackedAreaChart", dom = dom, width = 650
)
impactPlot$chart(margin = list(left = 100))
impactPlot$yAxis(axisLabel = yAxisLabel, width = 80)
impactPlot$xAxis(axisLabel = "Year", width = 70)
impactPlot
}
#' Prepare plot of number of events by year
#'
#' @param dt data.table
#' @param dom
#' @param yAxisLabel
#' @return plot
plot_events_by_year <- function(dt, dom = "eventsByYear", yAxisLabel = "Count") {
eventsByYear <- nPlot(
Count ~ Year,
data = dt,
type = "lineChart", dom = dom, width = 650
)
eventsByYear$chart(margin = list(left = 100))
eventsByYear$yAxis( axisLabel = yAxisLabel, width = 80)
eventsByYear$xAxis( axisLabel = "Year", width = 70)
eventsByYear
}
#' Prepare dataset for downloads
#'
#' @param dt data.table
#' @return data.table
prepare_downolads <- function(dt) {
dt %>% rename(
State = STATE, Count = COUNT,
Injuries = INJURIES, Fatalities = FATALITIES,
Property.damage = PROPDMG, Crops.damage = CROPDMG
) %>% mutate(State=state.abb[match(State, tolower(state.name))])
}
library(shiny)
# Plotting
library(ggplot2)
library(rCharts)
library(ggvis)
# Data processing libraries
library(data.table)
library(reshape2)
library(dplyr)
# Required by includeMarkdown
library(markdown)
# It has to loaded to plot ggplot maps on shinyapps.io
library(mapproj)
library(maps)
# Load helper functions
source("helpers.R", local = TRUE)
# Load data
states_map <- map_data("state")
dt <- fread('data/events.agg.csv') %>% mutate(EVTYPE = tolower(EVTYPE))
evtypes <- sort(unique(dt$EVTYPE))
# Shiny server
shinyServer(function(input, output, session) {
# Define and initialize reactive values
values <- reactiveValues()
values$evtypes <- evtypes
# Create event type checkbox
output$evtypeControls <- renderUI({
checkboxGroupInput('evtypes', 'Event types', evtypes, selected=values$evtypes)
})
# Add observers on clear and select all buttons
observe({
if(input$clear_all == 0) return()
values$evtypes <- c()
})
observe({
if(input$select_all == 0) return()
values$evtypes <- evtypes
})
# Preapre datasets
# Prepare dataset for maps
dt.agg <- reactive({
aggregate_by_state(dt, input$range[1], input$range[2], input$evtypes)
})
# Prepare dataset for time series
dt.agg.year <- reactive({
aggregate_by_year(dt, input$range[1], input$range[2], input$evtypes)
})
# Prepare dataset for downloads
dataTable <- reactive({
prepare_downolads(dt.agg())
})
# Render Plots
# Population impact by state
output$populationImpactByState <- renderPlot({
print(plot_impact_by_state (
dt = compute_affected(dt.agg(), input$populationCategory),
states_map = states_map,
year_min = input$range[1],
year_max = input$range[2],
title = "Population impact %d - %d (number of affected)",
fill = "Affected"
))
})
# Economic impact by state
output$economicImpactByState <- renderPlot({
print(plot_impact_by_state(
dt = compute_damages(dt.agg(), input$economicCategory),
states_map = states_map,
year_min = input$range[1],
year_max = input$range[2],
title = "Economic impact %d - %d (Million USD)",
fill = "Damages"
))
})
# Events by year
output$eventsByYear <- renderChart({
plot_events_by_year(dt.agg.year())
})
# Population impact by year
output$populationImpact <- renderChart({
plot_impact_by_year(
dt = dt.agg.year() %>% select(Year, Injuries, Fatalities),
dom = "populationImpact",
yAxisLabel = "Affected",
desc = TRUE
)
})
# Economic impact by state
output$economicImpact <- renderChart({
plot_impact_by_year(
dt = dt.agg.year() %>% select(Year, Crops, Property),
dom = "economicImpact",
yAxisLabel = "Total damage (Million USD)"
)
})
# Render data table and create download handler
output$table <- renderDataTable(
{dataTable()}, options = list(bFilter = FALSE, iDisplayLength = 50))
output$downloadData <- downloadHandler(
filename = 'data.csv',
content = function(file) {
write.csv(dataTable(), file, row.names=FALSE)
}
)
})
# This is the user-interface definition of a Shiny web application.
# You can find out more about building applications with Shiny here:
#
# http://www.rstudio.com/shiny/
#
library(shiny)
# Fix tag("div", list(...)) : could not find function "showOutâ¦
library(rCharts)
shinyUI(
navbarPage("Storm Database Explorer",
tabPanel("Plot",
sidebarPanel(
sliderInput("range",
"Range:",
min = 1950,
max = 2011,
value = c(1993, 2011),
sep = ""),
uiOutput("evtypeControls"),
actionButton(inputId = "clear_all", label = "Clear selection", icon = icon("check-square")),
actionButton(inputId = "select_all", label = "Select all", icon = icon("check-square-o"))
),
mainPanel(
tabsetPanel(
# Data by state
tabPanel(p(icon("map-marker"), "By state"),
column(3,
wellPanel(
radioButtons(
"populationCategory",
"Population impact category:",
c("Both" = "both", "Injuries" = "injuries", "Fatalities" = "fatalities"))
)
),
column(3,
wellPanel(
radioButtons(
"economicCategory",
"Economic impact category:",
c("Both" = "both", "Property damage" = "property", "Crops damage" = "crops"))
)
),
column(7,
plotOutput("populationImpactByState"),
plotOutput("economicImpactByState")
)
),
# Time series data
tabPanel(p(icon("line-chart"), "By year"),
h4('Number of events by year', align = "center"),
showOutput("eventsByYear", "nvd3"),
h4('Population impact by year', align = "center"),
showOutput("populationImpact", "nvd3"),
h4('Economic impact by year', align = "center"),
showOutput("economicImpact", "nvd3")
),
# Data
tabPanel(p(icon("table"), "Data"),
dataTableOutput(outputId="table"),
downloadButton('downloadData', 'Download')
)
)
)
),
tabPanel("About",
mainPanel(
includeMarkdown("include.md")
)
)
)
)
setwd("C:/Users/Md. Ihtesham/Documents/GitHub/Coursera-DDP-Shiny/shiny-app")
# This is the user-interface definition of a Shiny web application.
# You can find out more about building applications with Shiny here:
#
# http://www.rstudio.com/shiny/
#
library(shiny)
# Fix tag("div", list(...)) : could not find function "showOutâ¦
library(rCharts)
shinyUI(
navbarPage("Storm Database Explorer",
tabPanel("Plot",
sidebarPanel(
sliderInput("range",
"Range:",
min = 1950,
max = 2011,
value = c(1993, 2011),
sep = ""),
uiOutput("evtypeControls"),
actionButton(inputId = "clear_all", label = "Clear selection", icon = icon("check-square")),
actionButton(inputId = "select_all", label = "Select all", icon = icon("check-square-o"))
),
mainPanel(
tabsetPanel(
# Data by state
tabPanel(p(icon("map-marker"), "By state"),
column(3,
wellPanel(
radioButtons(
"populationCategory",
"Population impact category:",
c("Both" = "both", "Injuries" = "injuries", "Fatalities" = "fatalities"))
)
),
column(3,
wellPanel(
radioButtons(
"economicCategory",
"Economic impact category:",
c("Both" = "both", "Property damage" = "property", "Crops damage" = "crops"))
)
),
column(7,
plotOutput("populationImpactByState"),
plotOutput("economicImpactByState")
)
),
# Time series data
tabPanel(p(icon("line-chart"), "By year"),
h4('Number of events by year', align = "center"),
showOutput("eventsByYear", "nvd3"),
h4('Population impact by year', align = "center"),
showOutput("populationImpact", "nvd3"),
h4('Economic impact by year', align = "center"),
showOutput("economicImpact", "nvd3")
),
# Data
tabPanel(p(icon("table"), "Data"),
dataTableOutput(outputId="table"),
downloadButton('downloadData', 'Download')
)
)
)
),
tabPanel("About",
mainPanel(
includeMarkdown("include.md")
)
)
)
)
runApp()
